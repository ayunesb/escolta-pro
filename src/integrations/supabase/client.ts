// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';
// Demo shims
import { demoDb, demoRealtime, demoAuth } from '@/demo/shims';

const DEMO = import.meta.env.VITE_DEMO_MODE === 'true';

const SUPABASE_URL = import.meta.env.VITE_SUPABASE_URL || "https://isnezquuwepqcjkaupjh.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = import.meta.env.VITE_SUPABASE_ANON_KEY || "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImlzbmV6cXV1d2VwcWNqa2F1cGpoIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTUwNDA0MjEsImV4cCI6MjA3MDYxNjQyMX0.a7tTT1l98O1m1HSV7iUWxqs8lp5x3FUugCTXZ0MhZYg";

// Helper to read role override from URL (?as=client|company|guard) OR persisted localStorage value for demo mode
function getDemoRoleOverride(): 'client' | 'company' | 'guard' | null {
  if (typeof window === 'undefined') return null;
  const params = new URLSearchParams(window.location.search);
  const p = params.get('as');
  if (p === 'client' || p === 'company' || p === 'guard') {
    try { localStorage.setItem('demo_role', p); } catch {}
    return p;
  }
  // Fallback to persisted role
  try {
    const saved = localStorage.getItem('demo_role');
    if (saved === 'client' || saved === 'company' || saved === 'guard') return saved;
  } catch {}
  return null;
}

// Very small supabase-like chain builder for demo mode.
function createDemoQuery(table: string) {
  type Filter = { col: string; op: 'eq' | 'not'; value: unknown };
  const filters: Filter[] = [];
  let insertPayload: any = null; // eslint-disable-line @typescript-eslint/no-explicit-any
  let updatePayload: any = null; // eslint-disable-line @typescript-eslint/no-explicit-any
  let singleFlag = false;

  const api: Record<string, unknown> = {};

  function applyFilters<T extends Record<string, unknown>>(rows: T[]): T[] {
    return rows.filter(r => filters.every(f => {
      const val = (r as Record<string, unknown>)[f.col];
      if (f.op === 'eq') return val === f.value;
      if (f.op === 'not') return val !== f.value;
      return true;
    }));
  }

  function getData() {
    if (table === 'bookings') {
      // role context to scope list
      const role = getDemoRoleOverride() || 'client';
      const user = demoAuth(role);
      const data = demoDb.listBookings(role, user?.id || '');
      return applyFilters(data as unknown as Record<string, unknown>[]);
    }
    if (table === 'messages') {
      const bookingFilter = filters.find(f => f.col === 'booking_id');
      const bookingId = bookingFilter?.value as string | undefined;
      const msgs = bookingId ? demoDb.listMessages(bookingId) : [];
      return applyFilters(msgs as unknown as Record<string, unknown>[]);
    }
    return [];
  }

  async function execSelect() {
    let data = getData();
    if (insertPayload) data = [insertPayload];
    if (updatePayload) data = [updatePayload];
    return { data: singleFlag ? data[0] : data, error: null };
  }

  const chain = {
    select() { return chain; },
    order() { return chain; },
    limit() { return chain; },
    not(col: string, _op: string, value: unknown) { filters.push({ col, op: 'not', value }); return chain; },
    eq(col: string, value: unknown) { filters.push({ col, op: 'eq', value }); return chain; },
    insert(payload: unknown) {
      if (table === 'messages') {
        const p = payload as { booking_id: string; body: string; sender_id: string | null };
        insertPayload = demoDb.addMessage(p.booking_id, p.sender_id, p.body);
      } else if (table === 'bookings') {
        const p = payload as { pickup_address: string; start_ts: string; end_ts: string; total_mxn_cents: number; client_id: string; };
        insertPayload = demoDb.createBooking(p);
      }
      return chain; 
    },
    update(patch: Record<string, unknown>) {
      if (table === 'messages') {
        const idFilter = filters.find(f => f.col === 'id');
        if (idFilter && typeof idFilter.value === 'string') {
          // message edit
          const msgs = demoDb.listMessages(''); // will filter below - hack: we don't have listAll
          // fallback iterate state via recordPayment side effect not available; skip for brevity
        }
      } else if (table === 'bookings') {
        const idFilter = filters.find(f => f.col === 'id');
        if (idFilter && typeof idFilter.value === 'string') {
          updatePayload = demoDb.updateBooking(idFilter.value, patch as any); // eslint-disable-line @typescript-eslint/no-explicit-any
        }
      }
      return chain; 
    },
    single() { singleFlag = true; return chain; },
    async then(resolver: (value: { data: unknown; error: null }) => unknown) { const r = await execSelect(); return resolver(r); },
    async selectExecute() { return execSelect(); },
  } as unknown as {
    select: (...args: unknown[]) => typeof chain;
    order: (...args: unknown[]) => typeof chain;
    limit: (...args: unknown[]) => typeof chain;
    not: (col: string, op: string, value: unknown) => typeof chain;
    eq: (col: string, value: unknown) => typeof chain;
    insert: (payload: unknown) => typeof chain;
    update: (patch: Record<string, unknown>) => typeof chain;
    single: () => typeof chain;
    then: (resolver: (value: { data: unknown; error: null }) => unknown) => Promise<unknown>;
  };
  return chain;
}

function createDemoSupabase() {
  const role = getDemoRoleOverride() || 'client';
  const user = demoAuth(role);
  return {
    auth: {
      async getUser() { return { data: { user: { id: user?.id } } }; },
      async signInWithPassword() { return { data: {}, error: null }; },
      async signUp() { return { data: {}, error: null }; },
      async signOut() { return { error: null }; },
      onAuthStateChange(callback: (event: string, session: unknown) => void) {
        // Immediately invoke with a synthetic signed-in event for demo user
        try { callback('SIGNED_IN', { user: { id: user?.id } }); } catch {}
        return { data: { subscription: { unsubscribe: () => {} } } } as const;
      },
    },
    from(table: string) { return createDemoQuery(table); },
    channel(name: string) {
      return {
        on(_evt: string, _filter: Record<string, unknown>, cb: (payload: unknown) => void) {
          // For messages subscription we map booking id out of channel name if present
            const match = name.match(/messages:booking:(.+)$/);
          if (match) {
            const bookingId = match[1];
            demoRealtime.on(`messages:${bookingId}`, (m) => cb({ new: m }));
          }
          return { subscribe: () => ({}) };
        },
        subscribe() { return { data: { status: 'SUBSCRIBED' } }; },
        unsubscribe() { /* no-op */ },
      };
    },
    removeChannel() { /* no-op */ },
    functions: {
      async invoke(fn: string, opts: { body?: any }) { // eslint-disable-line @typescript-eslint/no-explicit-any
        if (fn === 'booking_accept') {
          const id = opts.body?.booking_id as string;
          if (id) demoDb.updateBooking(id, { status: 'assigned' });
          return { data: { message: 'accepted' }, error: null };
        }
        if (fn === 'assignment_update') {
          // No dedicated assignments table in demo; just echo
          return { data: { message: 'updated' }, error: null };
        }
        if (fn === 'document_signed_url') {
          return { data: { signed_url: 'blob:demo' }, error: null };
        }
        return { data: { ok: true }, error: null };
      }
    },
    storage: {
      from() {
        return {
          async list() { return { data: [], error: null }; },
          async upload() { return { data: { path: 'demo' }, error: null }; },
          async remove() { return { data: [], error: null }; },
        };
      }
    },
    // Minimal rpc shim - return empty data array unless specific procedure simulated later
    async rpc(_fn: string, _args?: Record<string, unknown>) {
      return { data: [], error: null };
    }
  } as unknown;
}

// Export real or demo supabase client
export const supabase: unknown = DEMO
  ? createDemoSupabase()
  : createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
      auth: {
        storage: localStorage,
        persistSession: true,
        autoRefreshToken: true,
      }
    });